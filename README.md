# ì´ë¯¸ì§€ ìºì‹œ ìƒ˜í”Œ ì•±

ì´ë¯¸ì§€ ìºì‹œë¥¼ ì ìš©í•˜ì—¬ ì´ë¯¸ì§€ ë¡œë”© ì†ë„ë¥¼ ê°œì„ í•˜ëŠ” ìƒ˜í”Œ ì•±ì…ë‹ˆë‹¤.
ë¸Œëœì¹˜ ë³„ë¡œ ë‹¤ì–‘í•œ ìºì‹œ ì „ëµì„ ì ìš©í•´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤!

- [Step1 : No Cache](https://github.com/murjune/Image-Cache-Sample/tree/step1-no-cache)
- [Step2 : Memory Cache](https://github.com/murjune/Image-Cache-Sample/tree/step2-memory-cache)
- [Step3 : Disk Cache](https://github.com/murjune/Image-Cache-Sample/tree/step3-disk-cache)
- [Step4 : LRU Cache](https://github.com/murjune/Image-Cache-Sample/tree/step4-lru-cache)

---

## ì†Œê°œ
ì•ˆë…•í•˜ì„¸ìš”! ì €ëŠ” í˜„ì¬ ìš°í…Œì½”ì—ì„œ ì•ˆë“œë¡œì´ë“œ ê°œë°œìë¡œ "PokeRogueHelper" í”„ë¡œì íŠ¸ë¥¼ ì§„í–‰í•˜ê³  ìˆìŠµë‹ˆë‹¤.

ì•±ì—ì„œ í™”ë©´ì„ ì´ë™í•  ë•Œë§ˆë‹¤ "í¬ì¼“ëª¬ ë°ì´í„°"ë¥¼ ë¶ˆëŸ¬ì˜¤ê³  ì´ë¯¸ì§€ë¥¼ ë Œë”ë§í•˜ëŠ” ì‘ì—…ì´ ë¹ˆë²ˆí•˜ê²Œ ë°œìƒí•˜ëŠ”ë°, ì´ë¡œ ì¸í•´ ì´ë¯¸ì§€ ë¡œë”© ì†ë„ê°€ ëŠë ¤ì§€ëŠ” ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.

ì €í¬ íŒ€ì€ `ìºì‹œ(Cache)`ë¥¼ í™œìš©í•˜ì—¬ ì•± ì„±ëŠ¥ì„ ê°œì„ í•˜ì˜€ìŠµë‹ˆë‹¤. í¬ì¼“ëª¬ì´ë¼ëŠ” ë„ë©”ì¸ íŠ¹ì„±ìƒ ë°ì´í„°ê°€ ìì£¼ ë³€ê²½ë˜ì§€ ì•Šê¸° ë•Œë¬¸ì—, ìºì‹œë¥¼ ì ìš©í•˜ì—¬ ë°ì´í„° ë¡œë”©ê³¼ ì´ë¯¸ì§€ ëœë”ë§ ì†ë„ë¥¼ í¬ê²Œ ê°œì„ í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

ì´ë²ˆ ê¸€ì—ì„œëŠ” ë¹ ë¥´ê³  íš¨ìœ¨ì ì¸ ë°ì´í„° ë¡œë“œë¥¼ ìœ„í•´ ë°˜ë“œì‹œ ì•Œì•„ì•¼ í•  ìºì‹œì— ëŒ€í•´ ì•Œì•„ë³´ê³ , ì´ë¯¸ì§€ ìºì‹œ ì‹¤ìŠµ ì˜ˆì œë¥¼ í†µí•´ ìºì‹œë¥¼ ì§ì ‘ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ ì†Œê°œí•˜ê² ìŠµë‹ˆë‹¤.

# 1. ìºì‹œ

ìºì‹œëŠ” `ë°ì´í„°ë¥¼ ì„ì‹œë¡œ ì €ì¥í•˜ëŠ” ì¥ì†Œ`ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.

ìì£¼ ì‚¬ìš©í•˜ëŠ” ë°ì´í„°ì˜ ê²½ìš° ë§¤ë²ˆ ë„¤íŠ¸ì›Œí¬ í†µì‹ ì„ í†µí•´ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ê²ƒì€ ë¹„íš¨ìœ¨ì ì…ë‹ˆë‹¤. ìµœì´ˆë¡œ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ë•Œ,`ìºì‹œ`ì— ë°ì´í„°ë¥¼ ì €ì¥í•˜ì—¬ `ë„¤í¬ì›Œí¬ í†µì‹ `ì„ ì¤„ì´ê³ , `ë°ì´í„° ë¡œë”© ì†ë„`ë¥¼ ê°œì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## 1-1) ë©”ëª¨ë¦¬ ìºì‹œ vs ë””ìŠ¤í¬ ìºì‹œ

ìºì‹œëŠ” ì €ì¥ ìœ„ì¹˜ì— ë”°ë¼ `ë©”ëª¨ë¦¬ ìºì‹œ`ì™€ `ë””ìŠ¤í¬ ìºì‹œ`ë¡œ ë‚˜ë‰©ë‹ˆë‹¤.  
ë‚´ê°€ ì €ì¥í•  `ë°ì´í„°ì˜ íŠ¹ì„±`ì— ë”°ë¼ ì ì ˆí•œ ìºì‹œ ë°©ë²•ì„ ì„ íƒí•´ì•¼í•©ë‹ˆë‹¤.

`ë©”ëª¨ë¦¬ ìºì‹œ`ëŠ” `RAM` ì— ì €ì¥ë˜ê¸° ë•Œë¬¸ì— ë¹ ë¥´ê²Œ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ìˆì§€ë§Œ, ì•±ì´ ì¢…ë£Œë˜ë©´ ë°ì´í„°ê°€ ì‚¬ë¼ì§‘ë‹ˆë‹¤.

`ë””ìŠ¤í¬ ìºì‹œ`ëŠ” `í•˜ë“œ ë””ìŠ¤í¬`ì— ì €ì¥ë˜ê¸° ë•Œë¬¸ì— ì•±ì´ ì¢…ë£Œë˜ì–´ë„ ë°ì´í„°ê°€ ìœ ì§€ë©ë‹ˆë‹¤. í•˜ì§€ë§Œ, ë©”ëª¨ë¦¬ ìºì‹œì— ë¹„í•´ ëŠë¦¬ê²Œ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë‹¤ìŒê³¼ ê°™ì€ ê¸°ì¤€ìœ¼ë¡œ ì ì ˆí•œ ìºì‹œ ë°©ë²•ì„ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

1. ë¹ ë¥´ê²Œ ë°ì´í„°ë¥¼ ë¡œë”©í•´ì•¼í•  ê²½ìš°: `ë©”ëª¨ë¦¬ ìºì‹œ`
2. ë°ì´í„°ë¥¼ ì¥ê¸°ê°„ ì €ì¥í•˜ê±°ë‚˜ ì•± ì¬ì‹œì‘ ì‹œ ë°ì´í„°ë¥¼ ìœ ì§€í•´ì•¼í•  ê²½ìš°: `ë””ìŠ¤í¬ ìºì‹œ`
3. ë°ì´í„°ê°€ ì¥ê¸°ê°„ ë³€ê²½ë˜ì§€ ì•ŠëŠ” ê²½ìš°: `ë””ìŠ¤í¬ ìºì‹œ`
4. ë°ì´í„°ê°€ ìì£¼ ë³€ê²½ë˜ëŠ” ê²½ìš°: `ë©”ëª¨ë¦¬ ìºì‹œ`
5. ë°ì´í„°ê°€ ì‹¤ì‹œê°„ìœ¼ë¡œ ë³€ê²½ë˜ëŠ” ê²½ìš°: `ìºì‹œ ì‚¬ìš© X`

## 1-2) ìºì‹œ ì˜¤ë²„í”Œë¡œìš°

> ìºì‹œë˜ëŠ” ë°ì´í„°ê°€ ë„ˆë¬´ ë§ì•„ì ¸ ìºì‹œì˜ í¬ê¸°ë¥¼ ì´ˆê³¼í•˜ê²Œ ë˜ë©´ ì–´ë–»ê²Œ ë ê¹Œìš”? ğŸ¤”

ìºì‹œì— ì €ì¥ëœ ë°ì´í„°ê°€ ë„ˆë¬´ ë§ì•„ì ¸ì„œ ìºì‹œì˜ í¬ê¸°ë¥¼ ì´ˆê³¼í•˜ê²Œ ë˜ëŠ” ê²½ìš°ë¥¼ `ìºì‹œ ì˜¤ë²„í”Œë¡œìš°(Cache Overflow)`ë¼ê³  í•©ë‹ˆë‹¤.
ìƒˆë¡œìš´ ë°ì´í„°ë¥¼ ìºì‹œì— ì €ì¥í•˜ê¸° ìœ„í•´ ì €ì¥ëœ ë°ì´í„° ì¤‘ ì¼ë¶€ëŠ”`ì‚­ì œ`ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.

ì´ë•Œ ì–´ë–¤ ë°ì´í„°ë¥¼ ë¨¼ì € ì‚­ì œí• ì§€ ê²°ì •í•˜ëŠ” ë°©ë²•ì„ `ìºì‹œ êµì²´ ì•Œê³ ë¦¬ì¦˜`ì´ë¼ê³  í•©ë‹ˆë‹¤.

## 1-3) ìºì‹œ êµì²´ ì•Œê³ ë¦¬ì¦˜

ìºì‹œ êµì²´ ì•Œê³ ë¦¬ì¦˜ ì¤‘ ê°€ì¥ ë§ì´ ì‚¬ìš©ë˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì€ `LRU` ì™€ `LFU` ì…ë‹ˆë‹¤.

1) LFU(Least Frequently Used): ê°€ì¥ ì ê²Œ ì‚¬ìš©ëœ ë°ì´í„°ë¥¼ ì‚­ì œí•˜ëŠ” ë°©ì‹
2) LRU(Least Recently Used): ê°€ì¥ ì˜¤ë˜ ì‚¬ìš©ë˜ì§€ ì•Šì€ ë°ì´í„°ë¥¼ ì‚­ì œí•˜ëŠ” ë°©ì‹

`LFU` ëŠ” `ë°ì´í„°ì˜ ì°¸ì¡° ë¹ˆë„ìˆ˜`ì— ì˜ê±°í•œ ìºì‹œ êµì²´ ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. ë§Œì•½ íŠ¹ì • ë°ì´í„°ê°€ ë‹¤ë¥¸ ë°ì´í„°ì— ë¹„í•´ ë” ìì£¼ ì‚¬ìš©ë˜ëŠ” ê²½ìš°ì— LFU ì•Œê³ ë¦¬ì¦˜ì´ ì í•©í•©ë‹ˆë‹¤.

- ex) `íŒŒì´ë¦¬` ë¼ëŠ” í¬ì¼“ëª¬ ì´ë¯¸ì§€ê°€ ë‹¤ë¥¸ í¬ì¼“ëª¬ì— ë¹„í•´ 3 ~ 4 ë°° ë§ì´ ëœë”ë§ëœë‹¤ë©´, `íŒŒì´ë¦¬`ëŠ” ë‹¤ë¥¸ í¬ì¼“ëª¬ì— ë¹„í•´ ë” ìì£¼ ì°¸ì¡°ë˜ëŠ” ë°ì´í„°ì…ë‹ˆë‹¤.

`LRU` ëŠ” `ì‹œê°„ ì§€ì—­ì„±`ì— ì˜ê±°í•œ ê°€ì¥ ë§ì´ ì‚¬ìš©ë˜ëŠ” ìºì‹œ êµì²´ ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. `ì‹œê°„ ì§€ì—­ì„±`ì´ë€ ì‚¬ìš©ìê°€ ê°€ì¥ ìµœê·¼ì— ì‚¬ìš©í•œ ë°ì´í„°ê°€ ê°€ì¥ ë†’ì€ í™•ë¥ ë¡œ ë‹¤ì‹œ ì‚¬ìš©ë  ê²ƒì´ë¼ëŠ” ê°œë…ì…ë‹ˆë‹¤.

- ex) ì‚¬ìš©ìê°€ ìµœê·¼ì— `í”¼ì¹´ì¸„` ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í–ˆë‹¤ë©´, ë‹¤ìŒì—ë„ `í”¼ì¹´ì¸„` ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•  í™•ë¥ ì´ ë†’ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

ë°ì´í„°ì˜ íŠ¹ì„±ì— ë”°ë¼ ì ì ˆí•œ ìºì‹œ êµì²´ ì•Œê³ ë¦¬ì¦˜ì„ ì„ íƒí•˜ì—¬ ìºì‹œë¥¼ ê´€ë¦¬í•´ë©´ ë©ë‹ˆë‹¤! ğŸ’ª

ì´ì œ ê°„ëµí•˜ê²Œ ìºì‹œì— ëŒ€í•´ ì•Œì•„ë³´ì•˜ìœ¼ë‹ˆ, ì‹¤ìŠµì„ í†µí•´ ì´ë¯¸ì§€ ìºì‹œë¥¼ êµ¬í˜„í•´ë³´ê² ìŠµë‹ˆë‹¤!

# 3. ì‹¤ìŠµ - ì´ë¯¸ì§€ ìºì‹œ

> ìì„¸í•œ ì½”ë“œëŠ” [ì‹¤ìŠµ ê¹ƒí—ˆë¸Œ ì£¼ì†Œ](https://github.com/murjune/Image-Cache-Sample?tab=readme-ov-file)ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!

![img_1.png](image/img_1.png)

ì´ë¯¸ì§€ URL ì„ í†µí•´ ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì™€ í™”ë©´ì— ëœë”ë§í•˜ëŠ” ê°„ë‹¨í•œ ìƒ˜í”Œì•±ì„ ë§Œë“¤ì–´ë³´ê² ìŠµë‹ˆë‹¤.

## Step1: ë„¤íŠ¸ì›Œí¬ í†µì‹ 

```kotlin
class ImageLoader(
    private val ImageService: PokemonImageService
) {
    suspend fun bitmaps(urls: List<String>): List<Bitmap> {
        return ImageService.bitmaps(urls)
    }
}
```

`ImageLoader` ì—ì„œ `ImageService` ë¥¼ í†µí•´ ë„¤íŠ¸ì›Œí¬ í†µì‹ í•˜ì—¬ í¬ì¼“ëª¬ ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ê² ìŠµë‹ˆë‹¤.

<img src="image/no_cache.gif" width="200"/>

ì´ë¯¸ì§€ ë¡œë”©ì´ ë„ˆë¬´ ì˜¤ë˜ê±¸ë¦¬ë„¤ìš”. ë©”ëª¨ë¦¬ ìºì‹œë¥¼ ì ìš©í•´ë³´ê² ìŠµë‹ˆë‹¤!

## Step2: ë©”ëª¨ë¦¬ ìºì‹œ ì ìš©

```kotlin
class ImageLoader(
    private val imageService: ImageService
) {
    private val cachedImages: MutableMap<String, Bitmap> = mutableMapOf<String, Bitmap>()

    suspend fun bitmaps(urls: List<String>): List<Bitmap> {
        if (cachedImages.keys.containsAll(urls.toSet())) {
            return urls.map { requireNotNull(cachedImages[it]) }
        }
        return imageService.bitmaps(urls).also { cacheImages(urls, it) }
    }

    fun clearCache() {
        cachedImages.clear()
    }

    private fun cacheImages(keys: List<String>, images: List<Bitmap>) {
        keys.forEachIndexed { index, key ->
            cachedImages[key] = images[index]
        }
    }
}
```
Map ìë£Œêµ¬ì¡°ë¥¼ í™œìš©í•˜ì—¬ ë©”ëª¨ë¦¬ ìºì‹œë¥¼ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤.

1) `cachedImages`ì— ì´ë¯¸ì§€ê°€ ìºì‹œë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•œ í›„, ìºì‹œë˜ì–´ ìˆìœ¼ë©´ ìºì‹œëœ ì´ë¯¸ì§€ë¥¼ ë°˜í™˜
2) ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ë„¤íŠ¸ì›Œí¬ í†µì‹ ì„ í†µí•´ ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¨ í›„, ìºì‹œì— ì €ì¥

ìœ„ì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ì´ë¯¸ì§€ë¥¼ ìºì‹œí•˜ë©´, ë™ì¼í•œ ì´ë¯¸ì§€ URL ì˜ ê²½ìš° ë¹ ë¥´ê²Œ ë¡œë“œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!

<img src="./image/memory_cache.gif" width="200"/>

ë°ì´í„°ë¥¼ ë¦¬í”„ë ˆì‰¬í•˜ë”ë¼ë„ ë¡œë”© í™”ë©´ì´ ë³´ì´ì§€ ì•Šì„ ì •ë„ë¡œ ì´ë¯¸ì§€ ë¡œë”©ì´ ë¹¨ë¼ì¡ŒìŠµë‹ˆë‹¤!
ê·¸ëŸ¬ë‚˜, ì•±ì„ ì¬ì‹œì‘í•˜ë©´ ì–´ë–¨ê¹Œìš”??

<img src="./image/memory_cache2.gif" width="200"/>

ë©”ëª¨ë¦¬ ìºì‹œ ë°©ì‹ì€ `RAM`ì— ìºì‹œí–ˆê¸° ë•Œë¬¸ì— í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë˜ë©´ ìºì‹œê°€ ë¹„ì›Œì§€ê²Œë©ë‹ˆë‹¤.  
ë”°ë¼ì„œ, ë„¤íŠ¸ì›Œí¬ í†µì‹ ê³¼ ë™ì¼í•˜ê²Œ ì´ë¯¸ì§€ë¥¼ ë‹¤ì‹œ ë¶ˆëŸ¬ì™€ì•¼í•©ë‹ˆë‹¤.

ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ `ë””ìŠ¤í¬ ìºì‹œ`ë¥¼ ì ìš©í•´ë³´ê² ìŠµë‹ˆë‹¤!

## Step3: ë””ìŠ¤í¬ ìºì‹œ ì ìš©

ì•ˆë“œë¡œì´ë“œ ë‚´ë¶€ ì €ì¥ì†Œë¥¼ í™œìš©í•˜ì—¬ `PokemonImageSaver` í´ë˜ìŠ¤ì— ì´ë¯¸ì§€ë¥¼ ì €ì¥í•˜ê³  ë¶ˆëŸ¬ì˜¤ëŠ” ê¸°ëŠ¥ì„ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.

```kotlin
class ImageSaver(context: Context) {
    private val cacheFolder: File = File(context.cacheDir, "pokemon")
        get() {...}

    suspend fun bitmaps(urls: List<String>): List<Bitmap> = withContext(Dispatchers.IO) {
        urls.mapNotNull { url ->
            val file = photoCacheFile(url)
            if (file.exists()) {
                BitmapFactory.decodeFile(file.absolutePath)
            } else {
                null
            }
        }
    }
    suspend fun saveImage(url: String, bitmap: Bitmap) = withContext(Dispatchers.IO) {
        photoCacheFile(url).outputStream().use { output ->
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, output)
        }
    }
```

- `saveImage` í•¨ìˆ˜ì—ì„œëŠ” Bitmap ì„ PNG í˜•ì‹ìœ¼ë¡œ ì••ì¶•í•˜ì—¬ ë‚´ë¶€ ì €ì¥ì†Œì— ì €ì¥í•©ë‹ˆë‹¤.
- `bitmaps` í•¨ìˆ˜ì—ì„œëŠ” `urls` ì— í•´ë‹¹í•˜ëŠ” ì´ë¯¸ì§€ íŒŒì¼ì´ ì¡´ì¬í•˜ë©´ Bitmap ìœ¼ë¡œ ë””ì½”ë”©í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.

```kotlin
class ImageLoader(
    private val imageService: ImageService,
    private val imageSaver: ImageSaver
) {
    private val cachedImages: MutableMap<String, Bitmap> = mutableMapOf<String, Bitmap>()

    suspend fun bitmaps(urls: List<String>): List<Bitmap> {
        if (isMemoryCached(urls)) {
            return urls.map { requireNotNull(cachedImages[it]) }
        }
        if (isDiskCached(urls)) {
            return imageSaver.bitmaps(urls).also { cacheImages(urls, it) }
        }

        return imageService.bitmaps(urls)
            .also { bitmap ->
                urls.zip(bitmap).forEach { (url, bitmap) ->
                    imageSaver.saveImage(url, bitmap)
                }
            }
            .also { bitmap ->
                cacheImages(urls, bitmap)
            }
    }
    ...
```
ì´ì œ PokemonImageLoader ì—ì„œ ë©”ëª¨ë¦¬ ìºì‹œì™€ ë””ìŠ¤í¬ ìºì‹œë¥¼ ëª¨ë‘ í™œìš©í•˜ì—¬ ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤.

1) ë©”ëª¨ë¦¬ ìºì‹œì— ì´ë¯¸ì§€ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
2) ë””ìŠ¤í¬ ìºì‹œì— ì´ë¯¸ì§€ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
3) ë„¤íŠ¸ì›Œí¬ í†µì‹ ì„ í†µí•´ ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¨ í›„, ë””ìŠ¤í¬ ìºì‹œ, ë©”ëª¨ë¦¬ ìºì‹œì— ì €ì¥

ì´ì œ ì•±ì„ ì¬ì‹œì‘í•´ë„ ë””ìŠ¤í¬ëœ ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì™€ ë¹ ë¥´ê²Œ í™”ë©´ì„ ë¡œë“œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

<img src="./image/disk_cache.gif" width="200"/>

## Step4: LRU ìºì‹œ êµì²´ ì•Œê³ ë¦¬ì¦˜ ì ìš©

ë‚´ë¶€ ì €ì¥ì†Œë‚˜ RAM ê³µê°„ì´ ë¶€ì¡±í•´ì§ˆ ê²½ìš°, ìºì‹œëœ ì´ë¯¸ì§€ ì¤‘ ì¼ë¶€ë¥¼ `ì‚­ì œ`í•œ í›„ ìƒˆë¡œìš´ ì´ë¯¸ì§€ë¥¼ ì €ì¥í•´ì•¼í•©ë‹ˆë‹¤.

### Step4-1) ë©”ëª¨ë¦¬ ìºì‹œ LRU ì ìš©

`ë©”ëª¨ë¦¬ ìºì‹œ`ì˜ ê²½ìš° ì•ˆë“œë¡œì´ë“œì—ì„œ ì œê³µí•˜ëŠ” `LRUCache`ë¥¼ í™œìš©í•˜ì—¬ LRU ìºì‹œ êµì²´ ì•Œê³ ë¦¬ì¦˜ì„ ì‰½ê²Œ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

`mutableMap` ì„ `LRUCache` ë¡œ ë³€ê²½í•´ì£¼ê² ìŠµë‹ˆë‹¤!

```kotlin
class ImageLoader(
    ...
) {
    private val cachedImages: LruCache<String, Bitmap> =
        lruCache(cacheSize(), sizeOf = { _, value -> value.byteCount / 1024 })

    private fun cacheSize(): Int {
        val maxMemory = (Runtime.getRuntime().maxMemory() / 1024).toInt()
        return maxMemory / 8
    }
}
```
lruCache() íŒ©í† ë¦¬ í•¨ìˆ˜ë¥¼ í†µí•´ `LRUCache` ë¥¼ ìƒì„±í•˜ì˜€ìŠµë‹ˆë‹¤.

- `cacheSize()` í•¨ìˆ˜ë¥¼ í†µí•´ ìºì‹œì˜ ìµœëŒ€ í¬ê¸° ë©”ëª¨ë¦¬ì˜ `1/8` ë¡œ ì„¤ì •í•˜ì˜€ìŠµë‹ˆë‹¤.
- `sizeOf` ëŠ” ìºì‹œì— ì €ì¥ë  ë°ì´í„° `í•˜ë‚˜`ì˜ í¬ê¸°ë¥¼ ê³„ì‚°í•˜ëŠ” ëŒë‹¤ì…ë‹ˆë‹¤.

ë§Œì•½, ìºì‹œì— ì¶”ê°€ëœ Bitmap ì˜ `byteCount` ê°€ `1024` ë³´ë‹¤ í¬ë‹¤ë©´, `1KB` ë‹¨ìœ„ë¡œ ìºì‹œì— ì €ì¥ë©ë‹ˆë‹¤.
lruCache() ì˜ ì‚¬ìš©ë²•ì´ ê¶ê¸ˆí•˜ì‹œë‹¤ë©´ [lruCache í•™ìŠµí…ŒìŠ¤íŠ¸](https://github.com/murjune/Image-Cache-Sample/blob/step4-lru-cache/app/src/test/java/sample/image/cache/LRUCacheStudyTest.kt) ë¥¼ ì°¸ê³ í•´ì£¼ì„¸ìš”!

> ì™œ `maxMemory / 8` ë¡œ ì„¤ì •í–ˆì„ê¹Œìš”? ğŸ¤”
> 
> ì¼ë°˜/hdpi ê¸°ê¸°ì˜ ê²½ìš° ìµœì†Œ `32MB` ì˜ ë©”ëª¨ë¦¬ë¥¼ ì œê³µí•˜ì—¬, `maxMemory / 8` ì •ë„ë¡œ ìºì‹œë¥¼ ì„¤ì •í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•˜ê³  ìˆìŠµë‹ˆë‹¤.
> 
> ë§Œì•½, 800x480 í•´ìƒë„ì˜ ê¸°ê¸°ì—ì„œ ì´ë¯¸ì§€ë¡œë§Œ êµ¬ì„±ëœ GridView ê°€ í™”ë©´ì— ê½‰ ì±„ìš¸ ê²½ìš°, ì•½ `1.5MB` ì˜ ë©”ëª¨ë¦¬ê°€ í•„ìš”í•˜ë‹¤ê³  í•©ë‹ˆë‹¤.
> ë”°ë¼ì„œ, 32MB / 8 = 4MB ì •ë„ë¡œ ì„¤ì •í•˜ë©´ ì•½ `2.5 Page` ì— í•´ë‹¹í•˜ëŠ” ì´ë¯¸ì§€ë¥¼ ìºì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> 
> [ë¹„íŠ¸ë§µ ìºì‹± ì•ˆë“œë¡œì´ë“œ ê³µì‹ë¬¸ì„œ](https://developer.android.com/topic/performance/graphics/cache-bitmap?hl=ko)

### Step4-2) ë””ìŠ¤í¬ ìºì‹œ LRU ì ìš©

`ë””ìŠ¤í¬ ìºì‹œ`ì˜ ê²½ìš°, ì•ˆë“œë¡œì´ë“œì—ì„œ ê³µì‹ì ìœ¼ë¡œ ì§€ì›í•˜ëŠ” `DiskLruCache` ëŠ” ì—†ìŠµë‹ˆë‹¤. ğŸ˜¢  
ë”°ë¼ì„œ, java ì˜ `File I/O` ë¥¼ í™œìš©í•˜ì—¬ LRU ìºì‹œ êµì²´ ì•Œê³ ë¦¬ì¦˜ì„ ì§ì ‘ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤.

ì´ëŠ” `ê°€ì¥ ì˜¤ë˜ì „ì— ì ‘ê·¼í•œ íŒŒì¼`ì„ ì°¾ì•„ êµì²´í•˜ê¸° ìœ„í•´ íŒŒì¼ì˜ `lastModified` ë¥¼ í˜„ì¬ ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•˜ëŠ” `updateFileAccessTime` í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤.

```kotlin
private fun updateFileAccessTime(file: File) {
    file.setLastModified(System.currentTimeMillis())
}
```

ê·¸ë¦¬ê³ , ë””ìŠ¤í¬ ìºì‹œì˜ í¬ê¸°ê°€ `MAX_DISK_CACHE_SIZE` ë¥¼ ì´ˆê³¼í•˜ë©´, `ê°€ì¥ ì˜¤ë˜ì „ì— ì ‘ê·¼í•œ íŒŒì¼`ë¶€í„° ì‚­ì œí•˜ëŠ” `manageDiskCacheSize()` í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤.

```kotlin
private fun manageDiskCacheSize() {
    val files = cacheFolder.listFiles() ?: return
    var totalSize = files.sumOf { it.length() }
    val maxSize = MAX_DISK_CACHE_SIZE

    if (totalSize > maxSize) {
        val sortedFiles = files.sortedBy { it.lastModified() }
        for (file in sortedFiles) {
            if (totalSize <= maxSize) break
            totalSize -= file.length()
            file.delete()
        }
    }
}
```

íŒŒì¼ì„ ì½ì„ ë•Œë§ˆë‹¤ `updateFileAccessTime()` í•¨ìˆ˜ë¥¼ í†µí•´ íŒŒì¼ì˜ `lastModified` ë¥¼ ì—…ë°ì´íŠ¸í•˜ê³ ,
`manageDiskCacheSize()` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ìºì‹œì˜ í¬ê¸°ë¥¼ ê´€ë¦¬í•˜ë„ë¡ í•˜ì˜€ìŠµë‹ˆë‹¤.

ì´ì œ `ë©”ëª¨ë¦¬ ê³¼ ë””ìŠ¤í¬ ìºì‹œ` ëª¨ë‘ LRU ìºì‹œ êµì²´ ì•Œê³ ë¦¬ì¦˜ì„ ì ìš©í•˜ì—¬ `ìºì‹œ ì˜¤ë²„í”Œë¡œìš°`ë¥¼ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!

# ë§ˆë¬´ë¦¬
ì•ˆë“œë¡œì´ë“œì—ì„œ `ìºì‹±`ì„ í†µí•´ ë°ì´í„° ë¡œë”© ì‹œê°„ì„ ì¤„ì´ê³ , ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì„ ì¤„ì—¬ ì„±ëŠ¥ì„ í–¥ìƒì‹œì¼œ ì‚¬ìš©ì ê²½í—˜ í–¥ìƒì— ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤.

ì´ë²ˆ ê¸€ì—ì„œëŠ” `ë©”ëª¨ë¦¬ ìºì‹œì™€ ë””ìŠ¤í¬ ìºì‹œ`ë¥¼ í™œìš©í•˜ì—¬ ì´ë¯¸ì§€ ìºì‹œë¥¼ êµ¬í˜„í•˜ëŠ” ë°©ë²•ê³¼ `ìºì‹œ êµì²´ ì•Œê³ ë¦¬ì¦˜`ì„ ì ìš©í•˜ì—¬ ìºì‹œ ì˜¤ë²„í”Œë¡œìš°ë¥¼ ë°©ì§€í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ì•˜ìŠµë‹ˆë‹¤.

ì•ˆë“œë¡œì´ë“œ ê°œë°œìë¼ë©´ Glide ë‚˜ Picasso ì™€ ê°™ì€ ì´ë¯¸ì§€ ë¡œë“œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ë©´ ë˜ëŠ”ë° ì§ì ‘ êµ¬í˜„í•  ì¼ì´ ì—†ì„ ê²ƒì´ë¼ê³  ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

í•˜ì§€ë§Œ, ì´ë²ˆ ê¸€ì„ í†µí•´ ìºì‹œë¥¼ ì§ì ‘ êµ¬í˜„í•´ë³´ë©´ì„œ ìºì‹œì˜ ë™ì‘ ì›ë¦¬ë¥¼ ì´í•´í•˜ì‹œëŠ” ê²ƒì´ ì¶”í›„ ìš°ë¦¬ì˜ ì„œë¹„ìŠ¤ì— íš¨ìœ¨ì ì¸ ìºì‹œ ì „ëµì„ ì„ íƒí•˜ê³  ì ìš©í•˜ëŠ” ë° ë„ì›€ì´ ë  ê²ƒì…ë‹ˆë‹¤! ğŸš€

ê°ì‚¬í•©ë‹ˆë‹¤! ğŸŒ¹

# ì°¸ê³  ë¬¸í—Œ

https://developer.android.com/topic/performance/graphics/cache-bitmap

https://github.com/JakeWharton/DiskLruCache